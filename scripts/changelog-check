#!/usr/bin/env ruby
require 'open3'
require 'optparse'

CHANGELOG_REGEX = %r{^changelog: (?<category>[\w -]{2,}): (?<change>.+)$}
# A valid entry has a line in a commit message in the form of:
# changelog: CATEGORY: CHANGE_DESCRIPTION
def is_valid_changelog?(line)
  matches = CHANGELOG_REGEX.match(line)
  !matches.nil?
end

def get_git_log(base_branch, source_branch)
  format = "--pretty=title: %s%nbody:%b%nDELIMITER"
  log, status = Open3.capture2(
    'git', 'log', format, "#{base_branch}...#{source_branch}"
  )

  raise 'git log failed' unless status.success?

  log.strip.split("DELIMITER").map { |x| x.split("\nbody:").map { |y| y.split(%r{[\r\n]})
    .filter { |x| x != "" } }}.map do |title_and_commit_messages|
      { title: title_and_commit_messages[0], commit_messages: title_and_commit_messages[1] }
    end
end

def any_changelog_lines?(base_branch, source_branch)
  get_git_log(base_branch, source_branch).any? do |log|
    log[:commit_messages].any? { |message| is_valid_changelog?(message) }
  end
end

def commit_messages_contain_skip_changelog?(base_branch, source_branch)
  log, status = Open3.capture2(
    'git', 'log', '--pretty=\'%B\'', "#{base_branch}...#{source_branch}"
  )
  raise 'git log failed' unless status.success?

  log.include?('[skip changelog]')
end

# Get the last valid changelog line for every Pull Request and tie it to the commit subject.
# Each PR should be squashed, which results in every PR being one commit. The commit messages
# in a squashed PR are concatencated with a leading "*" for each commit. Ex:
#
# commit b7cc1cdaf697decb9908cb125538e75bddc46489
# Author: IDP Committer <idp.committer@gsa.gov>
# Date:   Wed Feb 2 09:14:29 2022 -0500
#
#     LG-9998: Update Authentication (#9999)
#
#     * Update Authentication commit #1
#
#     changelog: Authentication: Updating Authentication (LG-9998)
#
#     * Authentication commit #2
def generate_changelog

end

def main(args)
  options = { base_branch: 'main' }
  basename = File.basename($0)

  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
      usage: #{basename} -s my-feature-branch [OPTIONS]

    EOM
    opts.on('-h', '--help', 'Display this message') do
      warn opts
      exit
    end

    opts.on('-b', '--base_branch BASE_BRANCH', 'Name of base branch, defaults to main') do |val|
      options[:base_branch] = val
    end

    opts.on('-g', '--generate', 'Generate changelog') do |val|
      options[:generate] = val
    end

    opts.on('-s', '--source_branch SOURCE_BRANCH', 'Name of source branch (required)') do |val|
      options[:source_branch] = val
    end
  end

  optparse.parse!

  generate_changelog() and return if options[:generate]
  abort(optparse.help) if options[:source_branch].nil?

  skip_check = commit_messages_contain_skip_changelog?(
    options[:base_branch],
    options[:source_branch],
  )
  return 0 if skip_check

  if any_changelog_lines?(options[:base_branch], options[:source_branch])
    exit 0
  else
    warn(
      <<~ERROR,
        A valid changelog line was not found.
        Changelog entries should be formatted as: - CATEGORY: CHANGE_DESCRIPTION

        Include "[skip changelog]" in a commit message to bypass this check.
      ERROR
    )

    exit 1
  end
end

main(ARGV) if __FILE__ == $0
